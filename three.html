<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Three.js Smooth Camera â€” Orthographic Version</title>
<style>
	body, html {
		margin: 0;
		padding: 20px;
		overflow: hidden;
		height: 100%;
		box-sizing: border-box;
	}
	.three-display {
		position: relative;
		top: 50%;
		left: 50%;
		transform: translate(-50%, -50%);
		width: 100%;
		height: 80vh;
	}
	#hover-card {
		position: absolute;
		top: 10px;
		right: 10px;
		padding: 12px 18px;
		background: rgba(255,255,255,0.9);
		color: #000;
		font-family: Arial, sans-serif;
		font-size: 14px;
		border-radius: 6px;
		box-shadow: 0 2px 8px rgba(0,0,0,0.2);
		display: none;
		z-index: 20;
	}
	canvas { display:block; width:100%; height:100%; }
	#ui { position:absolute; top:10px; left:10px; z-index:10; }
	button { display:block; margin-bottom:5px; padding:8px 12px; font-size:14px; }
</style>
</head>
<body>
	<div class="three-display" id="three-container">
		<div id="ui">
			<button id="cam1">Camera 1</button>
			<button id="cam2">Camera 2</button>
			<button id="toggle-glass">Toggle Glass</button>
		</div>
		<div id="hover-card">Hover Info</div>
	</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
<script src="helpers.js"></script>
<script>
const container = document.getElementById('three-container');

// --- Helper Toggle Flags ---
const SHOW_CAMERA_HELPERS = false;  // Set to false to hide camera helpers
const SHOW_LIGHT_HELPERS = false;   // Set to false to hide light helpers

// Scene + renderer
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xdbdbdb);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(window.devicePixelRatio || 1);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.autoClear = false;
container.appendChild(renderer.domElement);

// --- PERSPECTIVE CAMERA SETUP ---
let camera;
function createPerspectiveCamera(pos, target, fov=50){
	const aspect = container.clientWidth / container.clientHeight;
	const cam = new THREE.PerspectiveCamera(fov, aspect, 0.01, 1000);
	cam.position.copy(pos);
	cam.lookAt(target);
	cam.userData.fov = fov; // store for resize
	return cam;
}

// --- Helper to add outline ---
function addOutline(mesh, color=0x000000, scale=1.05) {
	const outline = new THREE.Mesh(
		mesh.geometry.clone(),
		new THREE.MeshBasicMaterial({
			color,
			side: THREE.BackSide,
			depthWrite: false,
			depthTest: true,
			polygonOffset: true,
			polygonOffsetFactor: 1,
			polygonOffsetUnits: 1
		})
	);
	outline.scale.multiplyScalar(scale);
	outline.userData.isOutline = true;
	mesh.add(outline);
	return outline;
}

function addCreaseEdges(mesh, thresholdAngleDeg = 20) {
	const edgesGeom = new THREE.EdgesGeometry(mesh.geometry, thresholdAngleDeg);
	const edgesMat = new THREE.LineBasicMaterial({ color: 0x000000, transparent: true, opacity: 1 });
	const edges = new THREE.LineSegments(edgesGeom, edgesMat);
	edges.userData.isCreaseEdges = true;
	edges.frustumCulled = false;
	edges.renderOrder = 2; // draw on top of mesh
	mesh.add(edges);
	return edges;
}

// Cube
const cubeGeometry = new THREE.BoxGeometry(1,1,1);
const cubeMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness:0.5, metalness:0.1 });
const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
cube.position.set(0,1,20);
cube.castShadow = true;
addOutline(cube);
scene.add(cube);

// Sphere
const sphere = new THREE.Mesh(new THREE.SphereGeometry(0.5,32,32), new THREE.MeshStandardMaterial({ color: 0xffffff }));
sphere.position.set(2,1,20);
sphere.castShadow = true;
addOutline(sphere);
scene.add(sphere);

// Cone
const coneGeometry = new THREE.ConeGeometry(0.5,1,32);
const coneMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
const cone = new THREE.Mesh(coneGeometry, coneMaterial);
cone.position.set(-2,1,20);
cone.castShadow = true;
addOutline(cone);
scene.add(cone);

// Ground as shadow catcher
const ground = new THREE.Mesh(
	new THREE.PlaneGeometry(50,50),
	new THREE.ShadowMaterial({ opacity:0.1 })
);
ground.rotation.x = -Math.PI/2;
ground.position.y=0;
ground.receiveShadow = true;
scene.add(ground);

// --- Lights ---
const ambientLight = new THREE.AmbientLight(0xffffff, .9);
scene.add(ambientLight);
const dirLight = new THREE.DirectionalLight(0xffffff, .9);
dirLight.position.set(20,20,-20);
dirLight.castShadow = true;
dirLight.target.position.set(0, 0, 0);
scene.add(dirLight);

// --- Light helpers ---
const lightHelpers = new LightHelpers(scene);
if (SHOW_LIGHT_HELPERS) {
	lightHelpers.addDirectionalLightHelper(dirLight, 10, 0xffffff);
	lightHelpers.addShadowCameraHelper(dirLight);
}

const c = dirLight.shadow.camera; // OrthographicCamera
c.left = -10;
c.right = 10;
c.top = 10;
c.bottom = -10;
c.near = 1;
c.far = 50;
c.updateProjectionMatrix();

// Increase resolution for cleaner edges
dirLight.shadow.mapSize.set(2048, 2048);

// GLTF / GLB loader with proper base paths and DRACO support
const loader = new THREE.GLTFLoader()
	.setPath('images/models/')
	.setResourcePath('images/models/');

// Uncomment if your asset is Draco-compressed
const draco = new THREE.DRACOLoader();
draco.setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/draco/');
loader.setDRACOLoader(draco);

// Cache-bust model requests to avoid stale .gltf/.bin during dev
THREE.DefaultLoadingManager.setURLModifier((url) => {
	if (url.indexOf('images/models/') !== -1) {
		const sep = url.indexOf('?') === -1 ? '?' : '&';
		return url + sep + 'v=' + Date.now();
	}
	return url;
});

let glass = null; // keep a reference outside the loader

loader.load(
	'factory1.glb',
	(glb) => {
		console.log('âœ… GLTF loaded:', glb);

		const root = glb.scene;

		// --- Center & scale ---
		const sizePre = new THREE.Vector3();
		new THREE.Box3().setFromObject(root).getSize(sizePre);
		const maxDim = Math.max(sizePre.x, sizePre.y, sizePre.z) || 1;
		const targetSize = 15; // desired max dimension in scene units
		const scale = targetSize / maxDim;
		root.scale.setScalar(scale);

		// Recompute bounds after scaling
		const box = new THREE.Box3().setFromObject(root);
		const center = new THREE.Vector3();
		box.getCenter(center);

		// --- Grab target meshes for hover effects (before traverse) ---
		const containersMesh = root.getObjectByName('containers');
		const stairsMesh = root.getObjectByName('stairs');
		
		if (containersMesh) {
			console.log('Found containers mesh:', containersMesh);
		} else {
			console.warn('âš ï¸ Containers mesh not found');
		}
		
		if (stairsMesh) {
			console.log('Found stairs mesh:', stairsMesh);
		} else {
			console.warn('âš ï¸ Stairs mesh not found');
		}

		// --- Traverse meshes ---
		root.traverse((obj) => {
			if (obj.isMesh && !obj.userData?.isOutline) {
				obj.castShadow = obj.receiveShadow = true;
				addCreaseEdges(obj, 30);
				
				// Check if mesh name contains "detection"
				if (obj.name.toLowerCase().includes('detection')) {
					// Make detection meshes truly invisible and non-interfering
					obj.material = new THREE.MeshBasicMaterial({ 
						transparent: true, 
						opacity: 0,
						side: THREE.DoubleSide,
						depthWrite: false,
						depthTest: false,
						alphaTest: 0.5,  // Discard pixels with alpha < 0.5
						blending: THREE.NoBlending  // No blending with background
					});
					// Disable shadow casting and receiving for detection meshes
					obj.castShadow = false;
					obj.receiveShadow = false;
					// Make them not affect lighting calculations
					obj.visible = true; // Keep visible for ray casting but invisible to rendering
					console.log('Applied truly invisible material to detection mesh:', obj.name);
					// Add to interactive meshes with target mesh and card text
					let targetMesh = null;
					let cardText = '';
					
					if (obj.name.toLowerCase().includes('container')) {
						targetMesh = containersMesh;
						cardText = 'Containers';
					} else if (obj.name.toLowerCase().includes('qa')) {
						targetMesh = stairsMesh;
						cardText = 'Stairs';
					}
					
					interactiveMeshes.push({ 
						mesh: obj, 
						base: new THREE.Color(0xffffff),
						targetMesh: targetMesh,
						cardText: cardText
					});
				} else {
					// Override material with simple white material for regular meshes
					obj.material = new THREE.MeshStandardMaterial({
						color: 0xffffff,
						roughness: 1,
						metalness: 0
					});
				}
			}
			if (obj.isMesh) {
				console.log('Mesh:', obj.name);
			}
		});

		// Detection meshes are now handled automatically in the traverse loop above

		// --- Add to scene ---
		scene.add(root);
	},
	(xhr) => {
		console.log(`ðŸ“¦ Loading... ${(xhr.loaded / xhr.total * 100).toFixed(2)}%`);
	},
	(err) => {
		console.error('âŒ GLB load error:', err);
	}
);

// --- UI handler for glass ---
document.getElementById('toggle-glass').addEventListener('click', () => {
	if (glass) {
		glass.visible = !glass.visible;
		console.log(`Glass visibility: ${glass.visible}`);
	}
});

// After any model load completes, set pan center and limit from its bounds
THREE.DefaultLoadingManager.onLoad = function(){
	// Find a recently added group as model root; fallback to scene center
	let modelRoot = null;
	for (let i = scene.children.length - 1; i >= 0; i--) {
		const child = scene.children[i];
		if (child.type === 'Group') { modelRoot = child; break; }
	}
	if (modelRoot) {
		const bbox = new THREE.Box3().setFromObject(modelRoot);
		const center = new THREE.Vector3();
		bbox.getCenter(center);
		sceneFocus.copy(center);
		const size = new THREE.Vector3();
		bbox.getSize(size);
		panLimit = Math.max(5, 0.75 * Math.max(size.x, size.z));
	}
};

// --- Camera homes ---
const homePositions = {
	cam1: { pos:new THREE.Vector3(15,8,15), target:new THREE.Vector3(0,0,0), color:0xffffff },
	cam2: { pos:new THREE.Vector3(0,25,25), target:new THREE.Vector3(0,0.5,0), color:0xffffff }
};

// --- Camera helpers ---
const cameraHelpers = new CameraHelpers(scene);
if (SHOW_CAMERA_HELPERS) {
	cameraHelpers.addCameraHelpers(homePositions);
}
let activeHome='cam1';
camera = createPerspectiveCamera(homePositions.cam1.pos, homePositions.cam1.target, fov = 20);
const minHeight=1, minDistance=5, maxDistance=50;
let panLimit=5; // updated after model load
let sceneFocus = new THREE.Vector3(0,0.5,0); // pan center updated from model

// --- Spherical helpers ---
function posFromSpherical(targetVec, az, pol, r){
	return new THREE.Vector3(
		targetVec.x + Math.cos(az)*Math.cos(pol)*r,
		targetVec.y + Math.sin(pol)*r,
		targetVec.z + Math.sin(az)*Math.cos(pol)*r
	);
}
function computeAnglesFromPos(pos,targetVec){
	const offset = new THREE.Vector3().subVectors(pos,targetVec);
	const radius = offset.length();
	const polar = Math.asin(offset.y/radius);
	const azimuth = Math.atan2(offset.z, offset.x);
	return { azimuth, polar, radius };
}
function clampPolar(polar,radius,targetY){
	const need=(minHeight-targetY)/radius;
	const safe=Math.max(-0.9999, Math.min(0.9999,need));
	const minPolar=Math.asin(safe);
	const maxPolar=Math.PI/2-0.01;
	return Math.max(minPolar, Math.min(maxPolar, polar));
}
function clampPanTarget(targetVec){
	const dx = targetVec.x - sceneFocus.x;
	const dz = targetVec.z - sceneFocus.z;
	const dist = Math.sqrt(dx*dx + dz*dz);
	if(dist>panLimit){
		const scale=panLimit/dist;
		targetVec.x=sceneFocus.x+dx*scale;
		targetVec.z=sceneFocus.z+dz*scale;
	}
}

// --- Camera state ---
let targetAz,targetPolar,targetRadius;
let currentAz,currentPolar,currentRadius;
let targetLookAt=new THREE.Vector3();
let currentLookAt=new THREE.Vector3();
let isTransitioning=false;

(function initCamera(){
	const home = homePositions.cam1;
	targetLookAt.copy(home.target);
	currentLookAt.copy(home.target);
	const ang = computeAnglesFromPos(home.pos,home.target);
	targetAz=currentAz=ang.azimuth;
	targetPolar=currentPolar=ang.polar;
	targetRadius=currentRadius=ang.radius;
	sphere.material.color.set(home.color);
})();

// --- Input & Zoom ---
let isLeft=false,isRight=false,lastX=0,lastY=0;
renderer.domElement.addEventListener('contextmenu',e=>e.preventDefault());
renderer.domElement.addEventListener('mousedown',e=>{
	lastX=e.clientX; lastY=e.clientY;
	if(e.button===0)isLeft=true;
	if(e.button===2)isRight=true;
});
window.addEventListener('mouseup',e=>{
	if(e.button===0)isLeft=false;
	if(e.button===2)isRight=false;
});
window.addEventListener('mousemove',e=>{
	const dx = e.clientX-lastX;
	const dy = e.clientY-lastY;
	lastX=e.clientX; lastY=e.clientY;
	if(isTransitioning) return;
	if(isLeft){
		const orbitSpeed=0.01;
		targetAz+=dx*orbitSpeed;
		targetPolar+=dy*orbitSpeed;
		targetPolar=clampPolar(targetPolar,targetRadius,targetLookAt.y);
	}else if(isRight){
		const panSpeed=0.01;
		const right = new THREE.Vector3();
		const up = new THREE.Vector3();
		camera.getWorldDirection(right);
		right.cross(camera.up).normalize();
		up.copy(camera.up);
		targetLookAt.addScaledVector(right,-dx*panSpeed);
		targetLookAt.addScaledVector(up,dy*panSpeed);
		clampPanTarget(targetLookAt);
	}
});
renderer.domElement.addEventListener('wheel', e=>{
	e.preventDefault();
	if(isTransitioning) return;
	const zoomFactor=1 + e.deltaY*0.001;
	camera.fov = Math.max(3, Math.min(25, camera.fov*zoomFactor));
	camera.updateProjectionMatrix();
});

// --- Camera switch ---
function goToHome(name){
	activeHome=name;
	const home = homePositions[name];
	targetLookAt.copy(home.target);
	const ang = computeAnglesFromPos(home.pos,home.target);
	targetAz=ang.azimuth;
	targetPolar=clampPolar(ang.polar,ang.radius,targetLookAt.y);
	targetRadius=Math.max(minDistance,Math.min(maxDistance,ang.radius));
	isTransitioning=true;
	sphere.material.color.set(home.color);
}
document.getElementById('cam1').addEventListener('click',()=>goToHome('cam1'));
document.getElementById('cam2').addEventListener('click',()=>goToHome('cam2'));

// --- Raycaster for hover ---
const raycaster=new THREE.Raycaster();
const mouse=new THREE.Vector2();
const hoverCard=document.getElementById('hover-card');

window.addEventListener('mousemove',e=>{
	const rect = renderer.domElement.getBoundingClientRect();
	mouse.x=((e.clientX-rect.left)/rect.width)*2-1;
	mouse.y=-((e.clientY-rect.top)/rect.height)*2+1;
});

const interactiveMeshes = [
	// Detection container will be added dynamically when model loads
];
let hoveredMesh = null;

function checkHover() {
	raycaster.setFromCamera(mouse, camera);
	const intersects = raycaster.intersectObjects(interactiveMeshes.map(o => o.mesh));
	if (intersects.length > 0) {
		hoveredMesh = intersects[0].object;
		// Find the interactive mesh object to get target mesh and card text
		const interactiveObj = interactiveMeshes.find(obj => obj.mesh === hoveredMesh);
		if (interactiveObj) {
			hoverCard.style.display = 'block';
			hoverCard.textContent = interactiveObj.cardText;
		}
		document.body.style.cursor = 'pointer';
	} else {
		hoveredMesh = null;
		hoverCard.style.display = 'none';
		document.body.style.cursor = 'default';
	}
}
function updateColors() {
	const hoverColor = new THREE.Color(0xff3333);
	const baseColor = new THREE.Color(0xffffff);
	
	// Update all target meshes
	interactiveMeshes.forEach(interactiveObj => {
		if (interactiveObj.targetMesh) {
			// If this is the hovered mesh, use hover color, otherwise use base color
			const target = (interactiveObj.mesh === hoveredMesh) ? hoverColor : baseColor;
			interactiveObj.targetMesh.material.color.lerp(target, 0.1);
		}
	});
}

// --- Animate ---
const smoothFactor=0.1;
function animate(){
	requestAnimationFrame(animate);
	currentAz+=(targetAz-currentAz)*smoothFactor;
	currentPolar+=(targetPolar-currentPolar)*smoothFactor;
	currentRadius+=(targetRadius-currentRadius)*smoothFactor;
	currentLookAt.lerp(targetLookAt,smoothFactor);

	const desiredPos=posFromSpherical(currentLookAt,currentAz,currentPolar,currentRadius);
	camera.position.copy(desiredPos);
	if(camera.position.y<minHeight)camera.position.y=minHeight;
	camera.lookAt(currentLookAt);

	cube.rotation.x+=0.01;
	cube.rotation.y+=0.01;


	checkHover();
	updateColors();
	// Update light helpers
	lightHelpers.helpers.forEach(helper => {
		if (helper.update) helper.update();
	});
	// Render
	renderer.render(scene,camera);

	// End transition when we're close enough to target
	if(isTransitioning){
		const homePos=homePositions[activeHome].pos;
		const d=camera.position.distanceTo(homePos);
		const azErr=Math.abs(currentAz-targetAz);
		const polErr=Math.abs(currentPolar-targetPolar);
		const rErr=Math.abs(currentRadius-targetRadius);
		if(d<0.02 && azErr<0.002 && polErr<0.002 && rErr<0.02) isTransitioning=false;
	}
}
animate();

// --- Resize ---
function resizeRenderer(){
	const w = container.clientWidth;
	const h = container.clientHeight;
	renderer.setSize(w,h);
	const aspect=w/h;
	camera.aspect = aspect;
	camera.updateProjectionMatrix();
}
window.addEventListener('resize',resizeRenderer);
resizeRenderer();
</script>
</body>
</html>
