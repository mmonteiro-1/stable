<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Three.js Smooth Camera — Orthographic Version</title>
<link rel="stylesheet" type="text/css" href="css/style.css" />
<style>
	body, html {
		margin: 0;
		padding: 20px;
		overflow: hidden;
		height: 100%;
		box-sizing: border-box;
	}
	.three-display {
		position: relative;
		width: 100%;
		height: 80vh;
	}
	#hover-card {
		position: absolute;
		top: 10px;
		right: 10px;
		padding: 12px 18px;
		background: rgba(255,255,255,0.9);
		color: #000;
		font-family: Arial, sans-serif;
		font-size: 14px;
		border-radius: 6px;
		box-shadow: 0 2px 8px rgba(0,0,0,0.2);
		display: none;
		z-index: 20;
	}
	canvas { display:block; width:100%; height:100%; }
	button { display:none; }
</style>
</head>
<body>
	<div class="content">
		<section class="marginless">
			<div class="three-display" id="three-container">
				<div class="three-ui ">
					<div class="flex align-center button-ui">
						<div>
							<div class="text-vertical">ORBIT</div>
							<img  src="images/icons/icon_mouse_left_white.svg">
						</div>
						<div>
							<div class="text-vertical">PAN</div>
							<img  src="images/icons/icon_mouse_right_white.svg">
						</div>
						<div>
							<div class="text-vertical">ZOOM</div>
							<img  src="images/icons/icon_mouse_scroll_white.svg">
						</div>
					</div>
					<div class="button-ui selected" id="cameraFactory">
						<div>
							<img  src="images/icons/icon_factory_white.svg">
						</div>
					</div>
					<div class="button-ui" id="cameraProduction">
						<div>
							<img  src="images/icons/icon_conveyor_white.svg">
						</div>
					</div>
<!-- 					<button id="cameraFactory">Camera Factory</button>
 -->				</div>
				<div id="hover-card">Hover Info</div>
			</div>
		</section>
	</div>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
<script src="helpers.js"></script>
<script>
const container = document.getElementById('three-container');

// --- Helper Toggle Flags ---
const SHOW_CAMERA_HELPERS = false;  // Set to false to hide camera helpers
const SHOW_LIGHT_HELPERS = false;   // Set to false to hide light helpers

// Scene + renderer
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xc4c4c4);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(window.devicePixelRatio || 1);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.autoClear = false;
container.appendChild(renderer.domElement);

// --- PERSPECTIVE CAMERA SETUP ---
let camera;
function createPerspectiveCamera(pos, target, fov=50){
	const aspect = container.clientWidth / container.clientHeight;
	const cam = new THREE.PerspectiveCamera(fov, aspect, 0.01, 1000);
	cam.position.copy(pos);
	cam.lookAt(target);
	cam.userData.fov = fov; // store for resize
	return cam;
}


function addCreaseEdges(mesh, thresholdAngleDeg = 20) {
	const edgesGeom = new THREE.EdgesGeometry(mesh.geometry, thresholdAngleDeg);
	const edgesMat = new THREE.LineBasicMaterial({ color: 0x808080, transparent: true, opacity: 0.4 });
	const edges = new THREE.LineSegments(edgesGeom, edgesMat);
	edges.userData.isCreaseEdges = true;
	edges.frustumCulled = false;
	edges.renderOrder = 2; // draw on top of mesh
	mesh.add(edges);
	return edges;
}


// Ground as shadow catcher
const ground = new THREE.Mesh(
	new THREE.PlaneGeometry(50,50),
	new THREE.ShadowMaterial({ opacity:0.1 })
);
ground.rotation.x = -Math.PI/2;
ground.position.y=0;
ground.receiveShadow = true;
scene.add(ground);

// --- Lights ---
const ambientLight = new THREE.AmbientLight(0xffffff, .9);
scene.add(ambientLight);
const dirLight = new THREE.DirectionalLight(0x808080, .8);
dirLight.position.set(20,20,-20);
dirLight.castShadow = true;
dirLight.target.position.set(0, 0, 0);
scene.add(dirLight);

// --- Light helpers ---
const lightHelpers = new LightHelpers(scene);
if (SHOW_LIGHT_HELPERS) {
	lightHelpers.addDirectionalLightHelper(dirLight, 10, 0xffffff);
	lightHelpers.addShadowCameraHelper(dirLight);
}

const c = dirLight.shadow.camera; // OrthographicCamera
c.left = -10;
c.right = 10;
c.top = 10;
c.bottom = -10;
c.near = 1;
c.far = 50;
c.updateProjectionMatrix();

// Increase resolution for cleaner edges
dirLight.shadow.mapSize.set(4096, 4096);

// GLTF / GLB loader with proper base paths and DRACO support
const loader = new THREE.GLTFLoader()
	.setPath('images/models/')
	.setResourcePath('images/models/');

// Uncomment if your asset is Draco-compressed
const draco = new THREE.DRACOLoader();
draco.setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/draco/');
loader.setDRACOLoader(draco);

// Cache-bust model requests to avoid stale .gltf/.bin during dev
THREE.DefaultLoadingManager.setURLModifier((url) => {
	if (url.indexOf('images/models/') !== -1) {
		const sep = url.indexOf('?') === -1 ? '?' : '&';
		return url + sep + 'v=' + Date.now();
	}
	return url;
});


loader.load(
	'factory.glb',
	(glb) => {
		console.log('✅ GLTF loaded:', glb);

		const root = glb.scene;

		// --- Center & scale ---
		const sizePre = new THREE.Vector3();
		new THREE.Box3().setFromObject(root).getSize(sizePre);
		const maxDim = Math.max(sizePre.x, sizePre.y, sizePre.z) || 1;
		const targetSize = 15; // desired max dimension in scene units
		const scale = targetSize / maxDim;
		root.scale.setScalar(scale);

		// Recompute bounds after scaling
		const box = new THREE.Box3().setFromObject(root);
		const center = new THREE.Vector3();
		box.getCenter(center);

		// --- Grab target meshes for hover effects (before traverse) ---
		const productionMesh = root.getObjectByName('section_production');

		// --- Traverse meshes ---
		root.traverse((obj) => {
			if (obj.isMesh && !obj.userData?.isOutline) {
				obj.castShadow = obj.receiveShadow = true;
				
				// Only add crease edges to non-detection and non-floor meshes
				if (!obj.name.toLowerCase().includes('detection') && !obj.name.toLowerCase().includes('floor')) {
					addCreaseEdges(obj, 30);
				}
				
				// Check if mesh name contains "detection"
				if (obj.name.toLowerCase().includes('detection')) {
					// Make detection meshes truly invisible and non-interfering
					obj.material = new THREE.MeshBasicMaterial({ 
						transparent: true, 
						opacity: 0,
						side: THREE.DoubleSide,
						depthWrite: false,
						depthTest: false,
						alphaTest: 0.5,  // Discard pixels with alpha < 0.5
						blending: THREE.NoBlending  // No blending with background
					});
					// Disable shadow casting and receiving for detection meshes
					obj.castShadow = false;
					obj.receiveShadow = false;
					// Make them not affect lighting calculations
					obj.visible = true; // Keep visible for ray casting but invisible to rendering
					console.log('Applied truly invisible material to detection mesh:', obj.name);
					// Add to interactive meshes with target mesh
					let targetMesh = null;
					
					if (obj.name.toLowerCase().includes('production')) {
						targetMesh = productionMesh;
					}
					
					interactiveMeshes.push({ 
						mesh: obj, 
						base: new THREE.Color(0xffffff),
						targetMesh: targetMesh
					});
				} else {
					// Set section_production to always have red material
					if (obj.name.toLowerCase().includes('section_production')) {
						obj.material = new THREE.MeshStandardMaterial({
							color: 0xff3333, // Red color
							roughness: 1,
							metalness: 0
						});
					} else if (!obj.name.toLowerCase().includes('floor')) {
						// Preserve original material for floor mesh, override others with simple light gray material
						obj.material = new THREE.MeshStandardMaterial({
							color: 0xf4f4f4,
							roughness: 1,
							metalness: 0
						});
					}
				}
			}
			if (obj.isMesh) {
				console.log('Mesh:', obj.name);
			}
		});

		// Detection meshes are now handled automatically in the traverse loop above

		// --- Add to scene ---
		scene.add(root);
		
		
		
		
		
		
	},
	(xhr) => {
		console.log(`📦 Loading... ${(xhr.loaded / xhr.total * 100).toFixed(2)}%`);
	},
	(err) => {
		console.error('❌ GLB load error:', err);
	}
);


// After any model load completes, set pan center and limit from its bounds
THREE.DefaultLoadingManager.onLoad = function(){
	// Find a recently added group as model root; fallback to scene center
	let modelRoot = null;
	for (let i = scene.children.length - 1; i >= 0; i--) {
		const child = scene.children[i];
		if (child.type === 'Group') { modelRoot = child; break; }
	}
	if (modelRoot) {
		const bbox = new THREE.Box3().setFromObject(modelRoot);
		const center = new THREE.Vector3();
		bbox.getCenter(center);
		sceneFocus.copy(center);
		const size = new THREE.Vector3();
		bbox.getSize(size);
		panLimit = Math.max(5, 0.75 * Math.max(size.x, size.z));
	}
};

// --- Camera homes ---
const homePositions = {
	cameraFactory: { pos:new THREE.Vector3(30,20.5,22.5), target:new THREE.Vector3(0.5,0.5,0), fov:10, color:0xffffff },
	cameraProduction: { pos:new THREE.Vector3(-14.5,8,4), target:new THREE.Vector3(0.5,0,-2), fov:8, color:0xffffff }
};


// --- Camera helpers ---
const cameraHelpers = new CameraHelpers(scene);
if (SHOW_CAMERA_HELPERS) {
	cameraHelpers.addCameraHelpers(homePositions);
}
let activeHome='cameraFactory';
camera = createPerspectiveCamera(homePositions.cameraFactory.pos, homePositions.cameraFactory.target, homePositions.cameraFactory.fov);


const minHeight=1, minDistance=5, maxDistance=50;
let panLimit=5; // updated after model load
let sceneFocus = new THREE.Vector3(0,0.5,0); // pan center updated from model

// --- Spherical helpers ---
function posFromSpherical(targetVec, az, pol, r){
	return new THREE.Vector3(
		targetVec.x + Math.cos(az)*Math.cos(pol)*r,
		targetVec.y + Math.sin(pol)*r,
		targetVec.z + Math.sin(az)*Math.cos(pol)*r
	);
}
function computeAnglesFromPos(pos,targetVec){
	const offset = new THREE.Vector3().subVectors(pos,targetVec);
	const radius = offset.length();
	const polar = Math.asin(offset.y/radius);
	const azimuth = Math.atan2(offset.z, offset.x);
	return { azimuth, polar, radius };
}

function clampPolar(polar,radius,targetY){
	const need=(minHeight-targetY)/radius;
	const safe=Math.max(-0.9999, Math.min(0.9999,need));
	const minPolar=Math.asin(safe);
	const maxPolar=Math.PI/2-0.01;
	return Math.max(minPolar, Math.min(maxPolar, polar));
}

// Helper function to find shortest angular distance
function shortestAngularDistance(current, target) {
	let diff = target - current;
	// Normalize to [-π, π]
	while (diff > Math.PI) diff -= 2 * Math.PI;
	while (diff < -Math.PI) diff += 2 * Math.PI;
	return current + diff;
}
function clampPanTarget(targetVec){
	const dx = targetVec.x - sceneFocus.x;
	const dz = targetVec.z - sceneFocus.z;
	const dist = Math.sqrt(dx*dx + dz*dz);
	if(dist>panLimit){
		const scale=panLimit/dist;
		targetVec.x=sceneFocus.x+dx*scale;
		targetVec.z=sceneFocus.z+dz*scale;
	}
}

// --- Camera state ---
let targetAz,targetPolar,targetRadius;
let currentAz,currentPolar,currentRadius;
let targetLookAt=new THREE.Vector3();
let currentLookAt=new THREE.Vector3();
let targetFov, currentFov;
let isTransitioning=false;

(function initCamera(){
	const home = homePositions.cameraFactory;
	targetLookAt.copy(home.target);
	currentLookAt.copy(home.target);
	const ang = computeAnglesFromPos(home.pos,home.target);
	targetAz=currentAz=ang.azimuth;
	targetPolar=currentPolar=ang.polar;
	targetRadius=currentRadius=ang.radius;
	targetFov=currentFov=home.fov;
	
})();

// --- Input & Zoom ---
let isLeft=false,isRight=false,lastX=0,lastY=0;
let hasDragged=false; // Track if mouse has moved while pressed
renderer.domElement.addEventListener('contextmenu',e=>e.preventDefault());
renderer.domElement.addEventListener('mousedown',e=>{
	lastX=e.clientX; lastY=e.clientY;
	hasDragged=false; // Reset drag flag on mouse down
	if(e.button===0)isLeft=true;
	if(e.button===2)isRight=true;
});
window.addEventListener('mouseup',e=>{
	if(e.button===0)isLeft=false;
	if(e.button===2)isRight=false;
});
window.addEventListener('mousemove',e=>{
	const dx = e.clientX-lastX;
	const dy = e.clientY-lastY;
	lastX=e.clientX; lastY=e.clientY;
	if(isTransitioning) return;
	if(isLeft){
		const orbitSpeed=0.01;
		targetAz+=dx*orbitSpeed;
		targetPolar+=dy*orbitSpeed;
		targetPolar=clampPolar(targetPolar,targetRadius,targetLookAt.y);
		// Mark as dragged if mouse moved while left button is pressed
		if(Math.abs(dx) > 2 || Math.abs(dy) > 2) hasDragged=true;
	}else if(isRight){
		const panSpeed=0.01;
		const right = new THREE.Vector3();
		const up = new THREE.Vector3();
		camera.getWorldDirection(right);
		right.cross(camera.up).normalize();
		up.copy(camera.up);
		targetLookAt.addScaledVector(right,-dx*panSpeed);
		targetLookAt.addScaledVector(up,dy*panSpeed);
		clampPanTarget(targetLookAt);
		// Mark as dragged if mouse moved while right button is pressed
		if(Math.abs(dx) > 2 || Math.abs(dy) > 2) hasDragged=true;
	}
});
renderer.domElement.addEventListener('wheel', e=>{
	e.preventDefault();
	if(isTransitioning) return;
	const zoomFactor=1 + e.deltaY*0.001;
	targetRadius = Math.max(minDistance, Math.min(maxDistance, targetRadius*zoomFactor));
});

// --- Camera switch ---
function goToHome(name, transitionDuration = 3000){
	activeHome=name;
	const home = homePositions[name];
	targetLookAt.copy(home.target);
	const ang = computeAnglesFromPos(home.pos,home.target);
	
	// Use shortest path for azimuth to avoid swirling
	targetAz = shortestAngularDistance(currentAz, ang.azimuth);
	targetPolar=clampPolar(ang.polar,ang.radius,targetLookAt.y);
	targetRadius=Math.max(minDistance,Math.min(maxDistance,ang.radius));
	
	// Set the target FOV (will be smoothly interpolated)
	targetFov = home.fov;
	
	
	
	
	isTransitioning=true;
	
	// Set transition end time for smoother completion detection
	window.transitionEndTime = Date.now() + transitionDuration;
}
document.getElementById('cameraFactory').addEventListener('click',()=>goToHome('cameraFactory'));
document.getElementById('cameraProduction').addEventListener('click',()=>goToHome('cameraProduction'));

// --- Raycaster for hover ---
const raycaster=new THREE.Raycaster();
const mouse=new THREE.Vector2();
const hoverCard=document.getElementById('hover-card');

window.addEventListener('mousemove',e=>{
	const rect = renderer.domElement.getBoundingClientRect();
	mouse.x=((e.clientX-rect.left)/rect.width)*2-1;
	mouse.y=-((e.clientY-rect.top)/rect.height)*2+1;
});

// Add click functionality to detection meshes
renderer.domElement.addEventListener('click', e => {
	// Only trigger click if there was no dragging
	if (hasDragged) return;
	
	raycaster.setFromCamera(mouse, camera);
	const intersects = raycaster.intersectObjects(interactiveMeshes.map(o => o.mesh));
	if (intersects.length > 0) {
		const clickedMesh = intersects[0].object;
		const interactiveObj = interactiveMeshes.find(obj => obj.mesh === clickedMesh);
		
		// Check detection mesh type and switch to appropriate camera
		if (clickedMesh.name.toLowerCase().includes('production')) {
			goToHome('cameraProduction');
		}
		// You can add more click actions here for other detection meshes
	}
});

const interactiveMeshes = [
	// Detection container will be added dynamically when model loads
];
let hoveredMesh = null;

function checkHover() {
	raycaster.setFromCamera(mouse, camera);
	const intersects = raycaster.intersectObjects(interactiveMeshes.map(o => o.mesh));
	if (intersects.length > 0) {
		hoveredMesh = intersects[0].object;
		// Find the interactive mesh object to get target mesh
		const interactiveObj = interactiveMeshes.find(obj => obj.mesh === hoveredMesh);
		if (interactiveObj) {
			hoverCard.style.display = 'block';
			hoverCard.textContent = 'Production';
		}
		document.body.style.cursor = 'pointer';
	} else {
		hoveredMesh = null;
		hoverCard.style.display = 'none';
		document.body.style.cursor = 'default';
	}
}
function updateColors() {
	const hoverColor = new THREE.Color(0xff3333);
	const baseColor = new THREE.Color(0xffffff);
	const hoverOutlineColor = new THREE.Color(0xffffff); // White for hover
	const baseOutlineColor = new THREE.Color(0xf4f4f4); // Light gray for default
	
	// Update crease edge colors only (mesh material stays constant)
	interactiveMeshes.forEach(interactiveObj => {
		if (interactiveObj.targetMesh) {
			// Update crease edge colors
			interactiveObj.targetMesh.traverse((child) => {
				if (child.userData.isCreaseEdges && child.material) {
					const targetOutlineColor = (interactiveObj.mesh === hoveredMesh) ? hoverOutlineColor : baseOutlineColor;
					child.material.color.lerp(targetOutlineColor, 0.1);
				}
			});
		}
	});
}

// --- Animate ---
const smoothFactor=0.05; // Much slower for smooth transitions

// Easing function for smoother transitions
function easeInOutCubic(t) {
	return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
}

function animate(){
	requestAnimationFrame(animate);
	
	// Use consistent, slow smoothing for smooth transitions
	const smooth = smoothFactor;
	
	currentAz+=(targetAz-currentAz)*smooth;
	currentPolar+=(targetPolar-currentPolar)*smooth;
	currentRadius+=(targetRadius-currentRadius)*smooth;
	currentLookAt.lerp(targetLookAt,smooth);
	
	// Smoothly interpolate FOV
	currentFov += (targetFov - currentFov) * smooth;
	camera.fov = currentFov;
	camera.updateProjectionMatrix();

	const desiredPos=posFromSpherical(currentLookAt,currentAz,currentPolar,currentRadius);
	camera.position.copy(desiredPos);
	if(camera.position.y<minHeight)camera.position.y=minHeight;
	camera.lookAt(currentLookAt);



	checkHover();
	updateColors();
	// Update light helpers
	lightHelpers.helpers.forEach(helper => {
		if (helper.update) helper.update();
	});
	// Render
	renderer.render(scene,camera);

	// End transition when we're close enough to target or time has elapsed
	if(isTransitioning){
		const homePos=homePositions[activeHome].pos;
		const d=camera.position.distanceTo(homePos);
		const azErr=Math.abs(currentAz-targetAz);
		const polErr=Math.abs(currentPolar-targetPolar);
		const rErr=Math.abs(currentRadius-targetRadius);
		const fovErr=Math.abs(currentFov-targetFov);
		const timeElapsed = window.transitionEndTime ? Date.now() > window.transitionEndTime : false;
		
		// End transition if close enough OR time has elapsed (more lenient thresholds)
		if((d<0.1 && azErr<0.01 && polErr<0.01 && rErr<0.1 && fovErr<0.1) || timeElapsed) {
			isTransitioning=false;
		}
	}
}
animate();

// --- Resize ---
function resizeRenderer(){
	const w = container.clientWidth;
	const h = container.clientHeight;
	renderer.setSize(w,h);
	const aspect=w/h;
	camera.aspect = aspect;
	camera.updateProjectionMatrix();
}
window.addEventListener('resize',resizeRenderer);
resizeRenderer();
</script>
</body>
</html>
