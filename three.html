<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Three.js Smooth Camera â€” Orthographic Version</title>
<style>
	body, html {
		margin: 0;
		padding: 20px;
		overflow: hidden;
		height: 100%;
		box-sizing: border-box;
	}
	.three-display {
		position: relative;
		top: 50%;
		left: 50%;
		transform: translate(-50%, -50%);
		width: 100%;
		height: 80vh;
	}
	#hover-card {
		position: absolute;
		top: 10px;
		right: 10px;
		padding: 12px 18px;
		background: rgba(255,255,255,0.9);
		color: #000;
		font-family: Arial, sans-serif;
		font-size: 14px;
		border-radius: 6px;
		box-shadow: 0 2px 8px rgba(0,0,0,0.2);
		display: none;
		z-index: 20;
	}
	canvas { display:block; width:100%; height:100%; }
	#ui { position:absolute; top:10px; left:10px; z-index:10; }
	button { display:block; margin-bottom:5px; padding:8px 12px; font-size:14px; }
</style>
</head>
<body>
	<div class="three-display" id="three-container">
		<div id="ui">
			<button id="cameraFactory">Camera Factory</button>
			
			<div id="camera-controls" style="margin-top: 10px; padding: 10px; background: rgba(255,255,255,0.9); border-radius: 6px; max-width: 300px;">
				<h4 style="margin: 0 0 10px 0; font-size: 14px;">Camera Debug</h4>
				<div style="display: flex; flex-direction: column; gap: 8px;">
					<!-- Camera Position -->
					<div>
						<label style="font-size: 12px; font-weight: bold;">Camera Position</label>
						<div style="display: flex; flex-direction: column; gap: 3px; margin-top: 3px;">
							<div style="display: flex; align-items: center; gap: 5px;">
								<label style="width: 15px; font-size: 11px;">X:</label>
								<input type="range" id="cam-x" min="-50" max="50" step="0.5" style="flex: 1;">
								<span id="cam-x-value" style="width: 35px; font-size: 11px; text-align: right;">0</span>
							</div>
							<div style="display: flex; align-items: center; gap: 5px;">
								<label style="width: 15px; font-size: 11px;">Y:</label>
								<input type="range" id="cam-y" min="0" max="50" step="0.5" style="flex: 1;">
								<span id="cam-y-value" style="width: 35px; font-size: 11px; text-align: right;">0</span>
							</div>
							<div style="display: flex; align-items: center; gap: 5px;">
								<label style="width: 15px; font-size: 11px;">Z:</label>
								<input type="range" id="cam-z" min="-50" max="50" step="0.5" style="flex: 1;">
								<span id="cam-z-value" style="width: 35px; font-size: 11px; text-align: right;">0</span>
							</div>
						</div>
					</div>
					
					<!-- Camera Target -->
					<div>
						<label style="font-size: 12px; font-weight: bold;">Camera Target</label>
						<div style="display: flex; flex-direction: column; gap: 3px; margin-top: 3px;">
							<div style="display: flex; align-items: center; gap: 5px;">
								<label style="width: 15px; font-size: 11px;">X:</label>
								<input type="range" id="target-x" min="-20" max="20" step="0.5" style="flex: 1;">
								<span id="target-x-value" style="width: 35px; font-size: 11px; text-align: right;">0</span>
							</div>
							<div style="display: flex; align-items: center; gap: 5px;">
								<label style="width: 15px; font-size: 11px;">Y:</label>
								<input type="range" id="target-y" min="0" max="20" step="0.5" style="flex: 1;">
								<span id="target-y-value" style="width: 35px; font-size: 11px; text-align: right;">0</span>
							</div>
							<div style="display: flex; align-items: center; gap: 5px;">
								<label style="width: 15px; font-size: 11px;">Z:</label>
								<input type="range" id="target-z" min="-20" max="20" step="0.5" style="flex: 1;">
								<span id="target-z-value" style="width: 35px; font-size: 11px; text-align: right;">0</span>
							</div>
						</div>
					</div>
					
					<!-- FOV -->
					<div>
						<div style="display: flex; align-items: center; gap: 5px;">
							<label style="width: 30px; font-size: 12px; font-weight: bold;">FOV:</label>
							<input type="range" id="cam-fov" min="1" max="120" step="1" style="flex: 1;">
							<span id="cam-fov-value" style="width: 35px; font-size: 11px; text-align: right;">20</span>
						</div>
					</div>
				</div>
			</div>
		</div>
		<div id="hover-card">Hover Info</div>
	</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
<script src="helpers.js"></script>
<script>
const container = document.getElementById('three-container');

// --- Helper Toggle Flags ---
const SHOW_CAMERA_HELPERS = false;  // Set to false to hide camera helpers
const SHOW_LIGHT_HELPERS = false;   // Set to false to hide light helpers

// Scene + renderer
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xdbdbdb);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(window.devicePixelRatio || 1);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.autoClear = false;
container.appendChild(renderer.domElement);

// --- PERSPECTIVE CAMERA SETUP ---
let camera;
function createPerspectiveCamera(pos, target, fov=50){
	const aspect = container.clientWidth / container.clientHeight;
	const cam = new THREE.PerspectiveCamera(fov, aspect, 0.01, 1000);
	cam.position.copy(pos);
	cam.lookAt(target);
	cam.userData.fov = fov; // store for resize
	return cam;
}

// --- Helper to add outline ---
function addOutline(mesh, color=0x000000, scale=1.05) {
	const outline = new THREE.Mesh(
		mesh.geometry.clone(),
		new THREE.MeshBasicMaterial({
			color,
			side: THREE.BackSide,
			depthWrite: false,
			depthTest: true,
			polygonOffset: true,
			polygonOffsetFactor: 1,
			polygonOffsetUnits: 1
		})
	);
	outline.scale.multiplyScalar(scale);
	outline.userData.isOutline = true;
	mesh.add(outline);
	return outline;
}

function addCreaseEdges(mesh, thresholdAngleDeg = 20) {
	const edgesGeom = new THREE.EdgesGeometry(mesh.geometry, thresholdAngleDeg);
	const edgesMat = new THREE.LineBasicMaterial({ color: 0x000000, transparent: true, opacity: 1 });
	const edges = new THREE.LineSegments(edgesGeom, edgesMat);
	edges.userData.isCreaseEdges = true;
	edges.frustumCulled = false;
	edges.renderOrder = 2; // draw on top of mesh
	mesh.add(edges);
	return edges;
}


// Ground as shadow catcher
const ground = new THREE.Mesh(
	new THREE.PlaneGeometry(50,50),
	new THREE.ShadowMaterial({ opacity:0.1 })
);
ground.rotation.x = -Math.PI/2;
ground.position.y=0;
ground.receiveShadow = true;
scene.add(ground);

// --- Lights ---
const ambientLight = new THREE.AmbientLight(0xffffff, .9);
scene.add(ambientLight);
const dirLight = new THREE.DirectionalLight(0xffffff, .9);
dirLight.position.set(20,20,-20);
dirLight.castShadow = true;
dirLight.target.position.set(0, 0, 0);
scene.add(dirLight);

// --- Light helpers ---
const lightHelpers = new LightHelpers(scene);
if (SHOW_LIGHT_HELPERS) {
	lightHelpers.addDirectionalLightHelper(dirLight, 10, 0xffffff);
	lightHelpers.addShadowCameraHelper(dirLight);
}

const c = dirLight.shadow.camera; // OrthographicCamera
c.left = -10;
c.right = 10;
c.top = 10;
c.bottom = -10;
c.near = 1;
c.far = 50;
c.updateProjectionMatrix();

// Increase resolution for cleaner edges
dirLight.shadow.mapSize.set(2048, 2048);

// GLTF / GLB loader with proper base paths and DRACO support
const loader = new THREE.GLTFLoader()
	.setPath('images/models/')
	.setResourcePath('images/models/');

// Uncomment if your asset is Draco-compressed
const draco = new THREE.DRACOLoader();
draco.setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/draco/');
loader.setDRACOLoader(draco);

// Cache-bust model requests to avoid stale .gltf/.bin during dev
THREE.DefaultLoadingManager.setURLModifier((url) => {
	if (url.indexOf('images/models/') !== -1) {
		const sep = url.indexOf('?') === -1 ? '?' : '&';
		return url + sep + 'v=' + Date.now();
	}
	return url;
});


loader.load(
	'factoryblender4.glb',
	(glb) => {
		console.log('âœ… GLTF loaded:', glb);

		const root = glb.scene;

		// --- Center & scale ---
		const sizePre = new THREE.Vector3();
		new THREE.Box3().setFromObject(root).getSize(sizePre);
		const maxDim = Math.max(sizePre.x, sizePre.y, sizePre.z) || 1;
		const targetSize = 15; // desired max dimension in scene units
		const scale = targetSize / maxDim;
		root.scale.setScalar(scale);

		// Recompute bounds after scaling
		const box = new THREE.Box3().setFromObject(root);
		const center = new THREE.Vector3();
		box.getCenter(center);

		// --- Grab target meshes for hover effects (before traverse) ---
		const departureMesh = root.getObjectByName('section_departure');
		const qaMesh = root.getObjectByName('section_qa');
		const officeMesh = root.getObjectByName('section_office');
		const arrivalMesh = root.getObjectByName('section_arrival');
		const climateMesh = root.getObjectByName('section_climate');
		const productionMesh = root.getObjectByName('section_production');
		
		if (departureMesh) {
			console.log('Found section_departure mesh:', departureMesh);
		} else {
			console.warn('âš ï¸ Section_departure mesh not found');
		}
		
		if (qaMesh) {
			console.log('Found section_qa mesh:', qaMesh);
		} else {
			console.warn('âš ï¸ Section_qa mesh not found');
		}
		
		if (officeMesh) {
			console.log('Found section_office mesh:', officeMesh);
		} else {
			console.warn('âš ï¸ Section_office mesh not found');
		}
		
		if (arrivalMesh) {
			console.log('Found section_arrival mesh:', arrivalMesh);
		} else {
			console.warn('âš ï¸ Section_arrival mesh not found');
		}

		// --- Traverse meshes ---
		root.traverse((obj) => {
			if (obj.isMesh && !obj.userData?.isOutline) {
				obj.castShadow = obj.receiveShadow = true;
				
				// Only add crease edges to non-detection meshes
				if (!obj.name.toLowerCase().includes('detection')) {
					addCreaseEdges(obj, 45);
				}
				
				// Check if mesh name contains "detection"
				if (obj.name.toLowerCase().includes('detection')) {
					// Make detection meshes truly invisible and non-interfering
					obj.material = new THREE.MeshBasicMaterial({ 
						transparent: true, 
						opacity: 0,
						side: THREE.DoubleSide,
						depthWrite: false,
						depthTest: false,
						alphaTest: 0.5,  // Discard pixels with alpha < 0.5
						blending: THREE.NoBlending  // No blending with background
					});
					// Disable shadow casting and receiving for detection meshes
					obj.castShadow = false;
					obj.receiveShadow = false;
					// Make them not affect lighting calculations
					obj.visible = true; // Keep visible for ray casting but invisible to rendering
					console.log('Applied truly invisible material to detection mesh:', obj.name);
					// Add to interactive meshes with target mesh and card text
					let targetMesh = null;
					let cardText = '';
					
					if (obj.name.toLowerCase().includes('container')) {
						targetMesh = departureMesh;
						cardText = 'Departure';
					} else if (obj.name.toLowerCase().includes('qa')) {
						targetMesh = qaMesh;
						cardText = 'QA';
					} else if (obj.name.toLowerCase().includes('office')) {
						targetMesh = officeMesh;
						cardText = 'Office';
					} else if (obj.name.toLowerCase().includes('arrival')) {
						targetMesh = arrivalMesh;
						cardText = 'Arrival';
					} else if (obj.name.toLowerCase().includes('climate')) {
						targetMesh = climateMesh;
						cardText = 'Climate';
					} else if (obj.name.toLowerCase().includes('production')) {
						targetMesh = productionMesh;
						cardText = 'Production';
					}
					
					interactiveMeshes.push({ 
						mesh: obj, 
						base: new THREE.Color(0xffffff),
						targetMesh: targetMesh,
						cardText: cardText
					});
				} else {
					// Override material with simple white material for regular meshes
					obj.material = new THREE.MeshStandardMaterial({
						color: 0xffffff,
						roughness: 1,
						metalness: 0
					});
				}
			}
			if (obj.isMesh) {
				console.log('Mesh:', obj.name);
			}
		});

		// Detection meshes are now handled automatically in the traverse loop above

		// --- Add to scene ---
		scene.add(root);
		
		// Create and position the departure card
		window.departureCard = createFacingCard('images/models/2dcard_departure.svg', 0.15);
		
		// Find the section_departure mesh to position the card above it
		let departureMeshForCard = null;
		root.traverse((obj) => {
			if (obj.name.toLowerCase().includes('section_departure')) {
				departureMeshForCard = obj;
			}
		});
		
		if (departureMeshForCard) {
			// Get the bounding box of the departure mesh
			const box = new THREE.Box3().setFromObject(departureMeshForCard);
			const center = box.getCenter(new THREE.Vector3());
			const size = box.getSize(new THREE.Vector3());
			
			// Position card above the mesh
			window.departureCard.position.set(center.x, center.y + size.y * 0.5 + 0.5, center.z);
			
			// Store the height level for other cards to match
			window.cardHeightLevel = center.y + size.y * 0.5 + 0.5;
			
			// Initially show the card (cameraFactory is the default camera)
			window.departureCard.visible = true;
			scene.add(window.departureCard);
		}
		
		// Create and position the QA card
		window.qaCard = createFacingCard('images/models/2dcard_qa.svg', 0.15);
		
		// Find the section_qa mesh to position the card above it
		let qaMeshForCard = null;
		root.traverse((obj) => {
			if (obj.name.toLowerCase().includes('section_qa')) {
				qaMeshForCard = obj;
			}
		});
		
		if (qaMeshForCard) {
			// Get the bounding box of the QA mesh
			const box = new THREE.Box3().setFromObject(qaMeshForCard);
			const center = box.getCenter(new THREE.Vector3());
			
			// Position card at the same height level as departure card
			window.qaCard.position.set(center.x, window.cardHeightLevel, center.z);
			
			// Initially show the card (cameraFactory is the default camera)
			window.qaCard.visible = true;
			scene.add(window.qaCard);
		}
		
		// Create and position the office card
		window.officeCard = createFacingCard('images/models/2dcard_office.svg', 0.15);
		
		// Find the section_office mesh to position the card above it
		let officeMeshForCard = null;
		root.traverse((obj) => {
			if (obj.name.toLowerCase().includes('section_office')) {
				officeMeshForCard = obj;
			}
		});
		
		if (officeMeshForCard) {
			// Get the bounding box of the office mesh
			const box = new THREE.Box3().setFromObject(officeMeshForCard);
			const center = box.getCenter(new THREE.Vector3());
			
			// Position card at the same height level as departure card
			window.officeCard.position.set(center.x, window.cardHeightLevel, center.z);
			
			// Initially show the card (cameraFactory is the default camera)
			window.officeCard.visible = true;
			scene.add(window.officeCard);
		}
		
		// Create and position the arrival card
		window.arrivalCard = createFacingCard('images/models/2dcard_arrival.svg', 0.15);
		
		// Find the section_arrival mesh to position the card above it
		let arrivalMeshForCard = null;
		root.traverse((obj) => {
			if (obj.name.toLowerCase().includes('section_arrival')) {
				arrivalMeshForCard = obj;
			}
		});
		
		if (arrivalMeshForCard) {
			// Get the bounding box of the arrival mesh
			const box = new THREE.Box3().setFromObject(arrivalMeshForCard);
			const center = box.getCenter(new THREE.Vector3());
			
			// Position card at the same height level as departure card
			window.arrivalCard.position.set(center.x, window.cardHeightLevel, center.z);
			
			// Initially show the card (cameraFactory is the default camera)
			window.arrivalCard.visible = true;
			scene.add(window.arrivalCard);
		}
		
		// Create and position the production card
		window.productionCard = createFacingCard('images/models/2dcard_production.svg', 0.15);
		
		// Find the section_production mesh to position the card above it
		let productionMeshForCard = null;
		root.traverse((obj) => {
			if (obj.name.toLowerCase().includes('section_production')) {
				productionMeshForCard = obj;
				console.log('âœ… Found section_production mesh:', obj.name);
			}
		});
		
		if (productionMeshForCard) {
			// Get the bounding box of the production mesh
			const box = new THREE.Box3().setFromObject(productionMeshForCard);
			const center = box.getCenter(new THREE.Vector3());
			
			// Position card at the same height level as departure card
			window.productionCard.position.set(center.x, window.cardHeightLevel, center.z);
			
			// Initially show the card (cameraFactory is the default camera)
			window.productionCard.visible = true;
			scene.add(window.productionCard);
			console.log('âœ… Production card positioned and added to scene');
		} else {
			console.log('âŒ section_production mesh not found - listing all meshes:');
			root.traverse((obj) => {
				if (obj.isMesh && obj.name.toLowerCase().includes('section')) {
					console.log('  - Found section mesh:', obj.name);
				}
			});
		}
		
		// Create and position the climate card
		window.climateCard = createFacingCard('images/models/2dcard_climate.svg', 0.15);
		
		// Find the section_climate mesh to position the card above it
		let climateMeshForCard = null;
		root.traverse((obj) => {
			if (obj.name.toLowerCase().includes('section_climate')) {
				climateMeshForCard = obj;
				console.log('âœ… Found section_climate mesh:', obj.name);
			}
		});
		
		if (climateMeshForCard) {
			// Get the bounding box of the climate mesh
			const box = new THREE.Box3().setFromObject(climateMeshForCard);
			const center = box.getCenter(new THREE.Vector3());
			
			// Position card at the same height level as departure card
			window.climateCard.position.set(center.x, window.cardHeightLevel, center.z);
			
			// Initially show the card (cameraFactory is the default camera)
			window.climateCard.visible = true;
			scene.add(window.climateCard);
			console.log('âœ… Climate card positioned and added to scene');
		} else {
			console.log('âŒ section_climate mesh not found');
		}
	},
	(xhr) => {
		console.log(`ðŸ“¦ Loading... ${(xhr.loaded / xhr.total * 100).toFixed(2)}%`);
	},
	(err) => {
		console.error('âŒ GLB load error:', err);
	}
);


// After any model load completes, set pan center and limit from its bounds
THREE.DefaultLoadingManager.onLoad = function(){
	// Find a recently added group as model root; fallback to scene center
	let modelRoot = null;
	for (let i = scene.children.length - 1; i >= 0; i--) {
		const child = scene.children[i];
		if (child.type === 'Group') { modelRoot = child; break; }
	}
	if (modelRoot) {
		const bbox = new THREE.Box3().setFromObject(modelRoot);
		const center = new THREE.Vector3();
		bbox.getCenter(center);
		sceneFocus.copy(center);
		const size = new THREE.Vector3();
		bbox.getSize(size);
		panLimit = Math.max(5, 0.75 * Math.max(size.x, size.z));
	}
};

// --- Camera homes ---
const homePositions = {
	cameraFactory: { pos:new THREE.Vector3(30,20.5,22.5), target:new THREE.Vector3(0.5,0.5,0), fov:10, color:0xffffff },
	cameraQA: { pos:new THREE.Vector3(30,20.5,22.5), target:new THREE.Vector3(0.5,0,0.5), fov:4, color:0xffffff },
	cameraDeparture: { pos:new THREE.Vector3(14.5,15,16.5), target:new THREE.Vector3(3.5,0,0), fov:6, color:0xffffff },
	cameraArrival: { pos:new THREE.Vector3(16,8,-4), target:new THREE.Vector3(-5,0,2.5), fov:6, color:0xffffff },
	cameraOffice: { pos:new THREE.Vector3(24,8.5,-26.5), target:new THREE.Vector3(3.5,1,-3.5), fov:6, color:0xffffff },
	cameraClimate: { pos:new THREE.Vector3(-1.5,6,7), target:new THREE.Vector3(-3,0,-2.5), fov:8, color:0xffffff },
	cameraProduction: { pos:new THREE.Vector3(-14.5,8,4), target:new THREE.Vector3(0.5,0,-2), fov:8, color:0xffffff }
};

// --- Create 2D cards that face camera ---
function createFacingCard(svgPath, size = 2) {
	// Create texture from SVG file with proper loading callbacks
	const texture = new THREE.TextureLoader().load(
		svgPath,
		// onLoad callback
		(texture) => {
			console.log('âœ… SVG card loaded successfully:', svgPath);
			texture.needsUpdate = true;
			
			// Calculate proper aspect ratio from texture dimensions
			const aspectRatio = texture.image.width / texture.image.height;
			console.log('ðŸ“ SVG aspect ratio:', aspectRatio.toFixed(2));
			
			// Update sprite scale to respect original aspect ratio
			sprite.scale.set(size * aspectRatio, size, 1);
		},
		// onProgress callback
		(progress) => {
			console.log('ðŸ“¦ Loading SVG card...', (progress.loaded / progress.total * 100).toFixed(2) + '%');
		},
		// onError callback
		(error) => {
			console.error('âŒ Failed to load SVG card:', svgPath, error);
		}
	);
	
	// Create sprite material
	const spriteMaterial = new THREE.SpriteMaterial({ 
		map: texture,
		transparent: true,
		alphaTest: 0.1
	});
	
	// Create sprite
	const sprite = new THREE.Sprite(spriteMaterial);
	// Initial scale (will be updated in onLoad callback)
	sprite.scale.set(size, size, 1);
	
	return sprite;
}

// --- Camera helpers ---
const cameraHelpers = new CameraHelpers(scene);
if (SHOW_CAMERA_HELPERS) {
	cameraHelpers.addCameraHelpers(homePositions);
}
let activeHome='cameraFactory';
camera = createPerspectiveCamera(homePositions.cameraFactory.pos, homePositions.cameraFactory.target, homePositions.cameraFactory.fov);

// --- Camera debugger ---
let cameraDebugger;
// Initialize camera debugger after camera is created
cameraDebugger = new CameraDebugger(camera, homePositions, activeHome);

const minHeight=1, minDistance=5, maxDistance=50;
let panLimit=5; // updated after model load
let sceneFocus = new THREE.Vector3(0,0.5,0); // pan center updated from model

// --- Spherical helpers ---
function posFromSpherical(targetVec, az, pol, r){
	return new THREE.Vector3(
		targetVec.x + Math.cos(az)*Math.cos(pol)*r,
		targetVec.y + Math.sin(pol)*r,
		targetVec.z + Math.sin(az)*Math.cos(pol)*r
	);
}
function computeAnglesFromPos(pos,targetVec){
	const offset = new THREE.Vector3().subVectors(pos,targetVec);
	const radius = offset.length();
	const polar = Math.asin(offset.y/radius);
	const azimuth = Math.atan2(offset.z, offset.x);
	return { azimuth, polar, radius };
}

// Make function accessible to CameraDebugger
window.computeAnglesFromPos = computeAnglesFromPos;

// Function to update spherical coordinates from CameraDebugger
function updateSphericalCoords(azimuth, polar, radius) {
	targetAz = currentAz = azimuth;
	targetPolar = currentPolar = polar;
	targetRadius = currentRadius = radius;
}
window.updateSphericalCoords = updateSphericalCoords;
function clampPolar(polar,radius,targetY){
	const need=(minHeight-targetY)/radius;
	const safe=Math.max(-0.9999, Math.min(0.9999,need));
	const minPolar=Math.asin(safe);
	const maxPolar=Math.PI/2-0.01;
	return Math.max(minPolar, Math.min(maxPolar, polar));
}
function clampPanTarget(targetVec){
	const dx = targetVec.x - sceneFocus.x;
	const dz = targetVec.z - sceneFocus.z;
	const dist = Math.sqrt(dx*dx + dz*dz);
	if(dist>panLimit){
		const scale=panLimit/dist;
		targetVec.x=sceneFocus.x+dx*scale;
		targetVec.z=sceneFocus.z+dz*scale;
	}
}

// --- Camera state ---
let targetAz,targetPolar,targetRadius;
let currentAz,currentPolar,currentRadius;
let targetLookAt=new THREE.Vector3();
let currentLookAt=new THREE.Vector3();
let targetFov, currentFov;
let isTransitioning=false;

(function initCamera(){
	const home = homePositions.cameraFactory;
	targetLookAt.copy(home.target);
	currentLookAt.copy(home.target);
	const ang = computeAnglesFromPos(home.pos,home.target);
	targetAz=currentAz=ang.azimuth;
	targetPolar=currentPolar=ang.polar;
	targetRadius=currentRadius=ang.radius;
	targetFov=currentFov=home.fov;
	
	// Make these accessible to CameraDebugger after initialization
	window.targetAz = targetAz;
	window.targetPolar = targetPolar;
	window.targetRadius = targetRadius;
	window.currentAz = currentAz;
	window.currentPolar = currentPolar;
	window.currentRadius = currentRadius;
	window.targetLookAt = targetLookAt;
	window.currentLookAt = currentLookAt;
})();

// --- Input & Zoom ---
let isLeft=false,isRight=false,lastX=0,lastY=0;
let hasDragged=false; // Track if mouse has moved while pressed
renderer.domElement.addEventListener('contextmenu',e=>e.preventDefault());
renderer.domElement.addEventListener('mousedown',e=>{
	lastX=e.clientX; lastY=e.clientY;
	hasDragged=false; // Reset drag flag on mouse down
	if(e.button===0)isLeft=true;
	if(e.button===2)isRight=true;
});
window.addEventListener('mouseup',e=>{
	if(e.button===0)isLeft=false;
	if(e.button===2)isRight=false;
});
window.addEventListener('mousemove',e=>{
	const dx = e.clientX-lastX;
	const dy = e.clientY-lastY;
	lastX=e.clientX; lastY=e.clientY;
	if(isTransitioning) return;
	if(isLeft){
		const orbitSpeed=0.01;
		targetAz+=dx*orbitSpeed;
		targetPolar+=dy*orbitSpeed;
		targetPolar=clampPolar(targetPolar,targetRadius,targetLookAt.y);
		// Mark as dragged if mouse moved while left button is pressed
		if(Math.abs(dx) > 2 || Math.abs(dy) > 2) hasDragged=true;
	}else if(isRight){
		const panSpeed=0.01;
		const right = new THREE.Vector3();
		const up = new THREE.Vector3();
		camera.getWorldDirection(right);
		right.cross(camera.up).normalize();
		up.copy(camera.up);
		targetLookAt.addScaledVector(right,-dx*panSpeed);
		targetLookAt.addScaledVector(up,dy*panSpeed);
		clampPanTarget(targetLookAt);
		// Mark as dragged if mouse moved while right button is pressed
		if(Math.abs(dx) > 2 || Math.abs(dy) > 2) hasDragged=true;
	}
});
renderer.domElement.addEventListener('wheel', e=>{
	e.preventDefault();
	if(isTransitioning) return;
	const zoomFactor=1 + e.deltaY*0.001;
	camera.fov = Math.max(3, Math.min(25, camera.fov*zoomFactor));
	camera.updateProjectionMatrix();
});

// --- Camera switch ---
function goToHome(name, transitionDuration = 3000){
	activeHome=name;
	const home = homePositions[name];
	targetLookAt.copy(home.target);
	const ang = computeAnglesFromPos(home.pos,home.target);
	targetAz=ang.azimuth;
	targetPolar=clampPolar(ang.polar,ang.radius,targetLookAt.y);
	targetRadius=Math.max(minDistance,Math.min(maxDistance,ang.radius));
	
	// Set the target FOV (will be smoothly interpolated)
	targetFov = home.fov;
	
	// Update window references for CameraDebugger
	window.targetAz = targetAz;
	window.targetPolar = targetPolar;
	window.targetRadius = targetRadius;
	window.targetLookAt = targetLookAt;
	
	// Show/hide cards based on active camera (all cards visible only in cameraFactory)
	if (window.departureCard) {
		window.departureCard.visible = (name === 'cameraFactory');
	}
	if (window.qaCard) {
		window.qaCard.visible = (name === 'cameraFactory');
	}
	if (window.officeCard) {
		window.officeCard.visible = (name === 'cameraFactory');
	}
	if (window.arrivalCard) {
		window.arrivalCard.visible = (name === 'cameraFactory');
	}
	if (window.productionCard) {
		window.productionCard.visible = (name === 'cameraFactory');
	}
	if (window.climateCard) {
		window.climateCard.visible = (name === 'cameraFactory');
	}
	
	// Update camera debugger
	if (cameraDebugger) {
		cameraDebugger.onCameraChange(name);
	}
	
	isTransitioning=true;
	
	// Set transition end time for smoother completion detection
	window.transitionEndTime = Date.now() + transitionDuration;
}
document.getElementById('cameraFactory').addEventListener('click',()=>goToHome('cameraFactory'));

// --- Raycaster for hover ---
const raycaster=new THREE.Raycaster();
const mouse=new THREE.Vector2();
const hoverCard=document.getElementById('hover-card');

window.addEventListener('mousemove',e=>{
	const rect = renderer.domElement.getBoundingClientRect();
	mouse.x=((e.clientX-rect.left)/rect.width)*2-1;
	mouse.y=-((e.clientY-rect.top)/rect.height)*2+1;
});

// Add click functionality to detection meshes
renderer.domElement.addEventListener('click', e => {
	// Only trigger click if there was no dragging
	if (hasDragged) return;
	
	raycaster.setFromCamera(mouse, camera);
	const intersects = raycaster.intersectObjects(interactiveMeshes.map(o => o.mesh));
	if (intersects.length > 0) {
		const clickedMesh = intersects[0].object;
		const interactiveObj = interactiveMeshes.find(obj => obj.mesh === clickedMesh);
		
		// Check detection mesh type and switch to appropriate camera
		if (clickedMesh.name.toLowerCase().includes('qa')) {
			goToHome('cameraQA');
		} else if (clickedMesh.name.toLowerCase().includes('container')) {
			goToHome('cameraDeparture');
		} else if (clickedMesh.name.toLowerCase().includes('arrival')) {
			goToHome('cameraArrival');
		} else if (clickedMesh.name.toLowerCase().includes('office')) {
			goToHome('cameraOffice');
		} else if (clickedMesh.name.toLowerCase().includes('climate')) {
			goToHome('cameraClimate');
		} else if (clickedMesh.name.toLowerCase().includes('production')) {
			goToHome('cameraProduction');
		}
		// You can add more click actions here for other detection meshes
	}
});

const interactiveMeshes = [
	// Detection container will be added dynamically when model loads
];
let hoveredMesh = null;

function checkHover() {
	raycaster.setFromCamera(mouse, camera);
	const intersects = raycaster.intersectObjects(interactiveMeshes.map(o => o.mesh));
	if (intersects.length > 0) {
		hoveredMesh = intersects[0].object;
		// Find the interactive mesh object to get target mesh and card text
		const interactiveObj = interactiveMeshes.find(obj => obj.mesh === hoveredMesh);
		if (interactiveObj) {
			hoverCard.style.display = 'block';
			hoverCard.textContent = interactiveObj.cardText;
		}
		document.body.style.cursor = 'pointer';
	} else {
		hoveredMesh = null;
		hoverCard.style.display = 'none';
		document.body.style.cursor = 'default';
	}
}
function updateColors() {
	const hoverColor = new THREE.Color(0xff3333);
	const baseColor = new THREE.Color(0xffffff);
	
	// Update all target meshes
	interactiveMeshes.forEach(interactiveObj => {
		if (interactiveObj.targetMesh) {
			// If this is the hovered mesh, use hover color, otherwise use base color
			const target = (interactiveObj.mesh === hoveredMesh) ? hoverColor : baseColor;
			interactiveObj.targetMesh.material.color.lerp(target, 0.1);
		}
	});
}

// --- Animate ---
const smoothFactor=0.05; // Much slower for smooth transitions

// Easing function for smoother transitions
function easeInOutCubic(t) {
	return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
}

function animate(){
	requestAnimationFrame(animate);
	
	// Use consistent, slow smoothing for smooth transitions
	const smooth = smoothFactor;
	
	currentAz+=(targetAz-currentAz)*smooth;
	currentPolar+=(targetPolar-currentPolar)*smooth;
	currentRadius+=(targetRadius-currentRadius)*smooth;
	currentLookAt.lerp(targetLookAt,smooth);
	
	// Smoothly interpolate FOV
	currentFov += (targetFov - currentFov) * smooth;
	camera.fov = currentFov;
	camera.updateProjectionMatrix();

	const desiredPos=posFromSpherical(currentLookAt,currentAz,currentPolar,currentRadius);
	camera.position.copy(desiredPos);
	if(camera.position.y<minHeight)camera.position.y=minHeight;
	camera.lookAt(currentLookAt);



	checkHover();
	updateColors();
	// Update light helpers
	lightHelpers.helpers.forEach(helper => {
		if (helper.update) helper.update();
	});
	// Render
	renderer.render(scene,camera);

	// End transition when we're close enough to target or time has elapsed
	if(isTransitioning){
		const homePos=homePositions[activeHome].pos;
		const d=camera.position.distanceTo(homePos);
		const azErr=Math.abs(currentAz-targetAz);
		const polErr=Math.abs(currentPolar-targetPolar);
		const rErr=Math.abs(currentRadius-targetRadius);
		const fovErr=Math.abs(currentFov-targetFov);
		const timeElapsed = window.transitionEndTime ? Date.now() > window.transitionEndTime : false;
		
		// End transition if close enough OR time has elapsed (more lenient thresholds)
		if((d<0.1 && azErr<0.01 && polErr<0.01 && rErr<0.1 && fovErr<0.1) || timeElapsed) {
			isTransitioning=false;
		}
	}
}
animate();

// --- Resize ---
function resizeRenderer(){
	const w = container.clientWidth;
	const h = container.clientHeight;
	renderer.setSize(w,h);
	const aspect=w/h;
	camera.aspect = aspect;
	camera.updateProjectionMatrix();
}
window.addEventListener('resize',resizeRenderer);
resizeRenderer();
</script>
</body>
</html>
